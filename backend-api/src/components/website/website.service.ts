import { HttpException, HttpStatus, Injectable } from '@nestjs/common';
import { WebsiteCreateDto } from './dto/website-create.dto';
import { InjectModel } from '@nestjs/mongoose';
import { Website } from './schemas/website.schema';
import { Model } from 'mongoose';
import { UserService } from 'src/components/user/user.service';
import { WebsiteResponseDto } from './dto/website-response.dto';
import { PatternCreateDto } from './dto/pattern-create.dto';
import { Pattern } from './schemas/pattern.schema';
import { Comment } from './schemas/comment.schema';
import { CommentCreateDto } from './dto/comment-create.dto';
import { ReplyCreateDto } from './dto/reply-create.dto';

@Injectable()
export class WebsiteService {
  constructor(
    @InjectModel(Website.name) private readonly websiteModel: Model<Website>,
    @InjectModel(Pattern.name) private readonly patternModel: Model<Pattern>,
    @InjectModel(Comment.name) private readonly commentModel: Model<Comment>,
    private readonly userService: UserService,
  ) {}

  async persistWebsiteDetails(websiteCreateDto: WebsiteCreateDto) {
    const existingUser = await this.userService.findUserById(
      websiteCreateDto.userId,
    );
    if (!existingUser) {
      throw new HttpException('User not found', HttpStatus.NOT_FOUND);
    }

    try {
      const newWebsite = new this.websiteModel(websiteCreateDto);
      await newWebsite.save();

      const updatedUser = await this.userService.updateUserWithWebsiteId(
        existingUser._id,
        newWebsite._id,
      );

      if (!updatedUser) {
        throw new HttpException(
          'Failed to update user with website ID',
          HttpStatus.INTERNAL_SERVER_ERROR,
        );
      }

      return {
        websiteId: newWebsite._id,
      };
    } catch (error) {
      throw new HttpException(
        'Failed to save website details',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  async fetchParticularWebsiteDetails(
    websiteId: string,
  ): Promise<WebsiteResponseDto> {
    const existingWebsite = await this.websiteModel.findById(websiteId).exec();
    if (!existingWebsite) {
      throw new HttpException(
        'Failed to fetch website details',
        HttpStatus.NOT_FOUND,
      );
    }
    const websiteResponseDto: WebsiteResponseDto = {
      websiteId: existingWebsite._id,
      baseUrl: existingWebsite.baseUrl,
      websiteName: existingWebsite.websiteName,
      userId: existingWebsite.userId,
      additionalUrls: existingWebsite.additionalUrls,
      description: existingWebsite.description,
      isCompleted: existingWebsite.isCompleted,
      phase: existingWebsite.phase,
    };
    return websiteResponseDto;
  }

  async getAllWebsiteDetailsForParticularUser(userId: string) {
    const websites = await this.websiteModel.find({ userId }).exec();

    const websiteResponseDtos: WebsiteResponseDto[] = websites.map(
      (website) => ({
        websiteId: website._id,
        baseUrl: website.baseUrl,
        websiteName: website.websiteName,
        userId: website.userId,
        additionalUrls: website.additionalUrls,
        description: website.description,
        isCompleted: website.isCompleted,
        phase: website.phase,
      }),
    );

    return websiteResponseDtos;
  }

  async addPatternInWebsite(
    websiteId: string,
    patternCreateDto: PatternCreateDto,
  ) {
    const existingUser = await this.userService.findUserById(
      patternCreateDto.expertId,
    );
    if (!existingUser) {
      throw new HttpException('User not found', HttpStatus.NOT_FOUND);
    }

    const newPattern: Pattern = new this.patternModel({
      type: patternCreateDto.type,
      websiteId: websiteId,
      isAutoGenerated: false,
      expertId: patternCreateDto.expertId,
      description: patternCreateDto.description,
      detectedUrl: patternCreateDto.detectedUrl,
    });

    try {
      await newPattern.save();
      return { patternId: newPattern._id };
    } catch (error) {
      throw new HttpException(
        'Failed to save pattern details',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  async addCommentToPattern(
    websiteId: string,
    patternId: string,
    commentCreateDto: CommentCreateDto,
  ) {
    const existingUser = await this.userService.findUserById(
      commentCreateDto.expertId,
    );
    if (!existingUser) {
      throw new HttpException('User not found', HttpStatus.NOT_FOUND);
    }

    const existingWebsite = await this.websiteModel.findById(websiteId).exec();
    if (!existingWebsite) {
      throw new HttpException('Website not found', HttpStatus.NOT_FOUND);
    }

    const existingPattern = await this.patternModel.findById(patternId).exec();
    if (!existingPattern) {
      throw new HttpException('Pattern not found', HttpStatus.NOT_FOUND);
    }

    const newComment = new this.commentModel({
      ...commentCreateDto,
      websiteId: websiteId,
      patternId: patternId,
    });

    try {
      const savedComment = await newComment.save();

      await this.patternModel.findByIdAndUpdate(
        patternId,
        { $push: { comments: savedComment } },
        { new: true },
      );

      return savedComment;
    } catch (error) {
      console.log(error);
      throw new HttpException(
        'Failed to add comment',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  async addReplyToComment(
    websiteId: string,
    patternId: string,
    commentId: string,
    replyCreateDto: ReplyCreateDto,
  ) {
    const existingUser = await this.userService.findUserById(
      replyCreateDto.expertId,
    );
    if (!existingUser) {
      throw new HttpException('User not found', HttpStatus.NOT_FOUND);
    }

    const existingWebsite = await this.websiteModel.findById(websiteId).exec();
    if (!existingWebsite) {
      throw new HttpException('Website not found', HttpStatus.NOT_FOUND);
    }

    const existingPattern = await this.patternModel.findById(patternId).exec();
    if (!existingPattern) {
      throw new HttpException('Pattern not found', HttpStatus.NOT_FOUND);
    }

    const existingComment = await this.commentModel.findById(commentId).exec();
    if (!existingComment) {
      throw new HttpException('Comment not found', HttpStatus.NOT_FOUND);
    }
    try {
      const updatedComment = await this.commentModel.findByIdAndUpdate(
        commentId,
        { $push: { replies: { ...replyCreateDto, createdAt: new Date() } } },
        { new: true },
      );

      await this.patternModel.findByIdAndUpdate(
        patternId,
        { $set: { 'comments.$[elem]': updatedComment } },
        { arrayFilters: [{ 'elem._id': commentId }], new: true },
      );

      return updatedComment;
    } catch (error) {
      console.log(error);
      throw new HttpException(
        'Failed to add reply',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}
